import tensorflow.compat.v1 as tf #'2.16.2'#tf.enable_eager_execution()import numpy as npimport deepxde as dde #'1.13.0'#from functools import partialclass HJ_PINN():        def __init__(self,                 a,                 b,                 layers = [2,30,30,1],                 initializer = 'He normal',                 activation = 'tanh',                 optimizer = 'adam',                 learning_rate = 0.001,                 metric = ["l2 relative error"],                 num_domain = 1000,                 num_boundary = 0,                 num_test = 200,                 iters = 2000,                 weights = []                 ):        self.a = a        self.b = b        self.layers = layers        self.initializer = initializer        self.activation = activation        self.optimizer = optimizer        self.lr = learning_rate        self.metric = metric        self.num_domain = num_domain        self.num_test = num_test        self.num_boundary = num_boundary        self.iterations = iters        self.weights = None               def solve(self, anchors = None, param_tune = False):                a = tf.Variable(self.a)        b = tf.Variable(self.b)        t_max = 1; t_min = 0        x_max = 2*np.pi; x_min = 0        x = np.linspace(x_min, x_max, 100)        t = np.linspace(t_min, t_max, 100)        X, T = np.meshgrid(x, t)        geom = dde.geometry.Rectangle((x_min,t_min), (x_max,t_max))        def boundary_bottom(z,on_boundary):              return dde.utils.isclose(z[0],x_min)        def boundary_top(z,on_boundary):              return dde.utils.isclose(z[0],x_max)                   bc_min_x = dde.icbc.DirichletBC (geom, lambda z: 0, boundary_bottom, component = 0)        bc_max_x = dde.icbc.DirichletBC (geom, lambda z: 0, boundary_top,    component = 0)        bcs = [bc_min_x, bc_max_x]                def HJ_deepxde(z,y):                phi = y[:, 0:1]            x = z[:, 0:1]            t = z[:, 1:2]                        dphi_dt = dde.grad.jacobian(phi,z,0,1)            dphi_dx = dde.grad.jacobian(phi,z,0,0)                    return a*dphi_dt  + b*tf.sin(x) * dphi_dx        def output_transform(z, q): # Here we applied the initial conditions as 'Hard constraints'            phi = q[:, 0:1]                x = z[:, 0:1]            t = z[:, 1:2]                return phi * tf.tanh(t) + tf.sin(x)        if param_tune == True:            parameters = [dde.callbacks.VariableValue([a,b], period=500)]            points, ys = anchors            observe = dde.icbc.PointSetBC(points, ys )            bcs = [bc_min_x, bc_max_x, observe]            anchors = points                    else:             parameters = []            bcs = bcs            anchors = None                                           data = dde.data.PDE(geom, HJ_deepxde,bcs,                        num_domain = self.num_domain,                        num_boundary = self.num_boundary,                        num_test = self.num_test,                        anchors = anchors                       )        net = dde.nn.FNN(self.layers, self.activation, self.initializer)        net.apply_output_transform(output_transform)                model = dde.Model(data, net)        model.compile(self.optimizer, lr = self.lr, verbose = 0 )        losshistory, train_state = model.train(iterations = self.iterations , display_every = 1000, verbose = 0, callbacks=parameters )                       y_pred = model.predict(np.stack((X.ravel(), T.ravel()), axis=-1)).reshape(len(x), len(t), 1)                if param_tune == False:            return x,t,y_pred        else:            return [x,t,y_pred] , parameters[0].value            def find_param(self, num_pts, noise_amp = 0.):                    X = np.random.uniform(0, 2*np.pi, num_pts)        T = np.random.uniform(0, 1, num_pts)               pts = np.stack([X,T], 1)        noise = noise_amp*np.random.uniform(-1, 1, [num_pts, 1])               anchors =  pts, np.sin(2*np.arctan(np.exp(-T)*np.tan(X/2))).reshape(num_pts, 1)+ noise        solution = self.solve(anchors = anchors, param_tune=True)                param_optim = solution[1]                    return param_optim    